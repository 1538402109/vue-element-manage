换肤不仅换element的颜色，也换掉项目中自己编写的颜色。主要分以下四步：

1.准备一个默认的颜色系列，此颜色系列是根据默认的基础色生成的。

​	比如默认基础色为"#409eff"，由此生成一个默认颜色系列为 ["409eff", "64,158,255", "53a8ff", "66b1ff", "79bbff", "8cc5ff", "a0cfff", "b3d8ff", "c6e2ff", "d9ecff", "ecf5ff", "3a8ee6"] 

```js
// 由基础颜色值生成一系列颜色值
getColors(theme) {
    // 实现sass的mix函数与#fff合并。与白色合并其实就是改变透明度。
    /* 
    $custom-primary-white__9:mix($custom-white, $custom-primary, 90%);
    $custom-primary-opacity__1:rgba($custom-primary,0.1);
    它们的效果是一样的
     */
    const tintColor = (color, tint) => {
        let red = parseInt(color.slice(0, 2), 16);
        let green = parseInt(color.slice(2, 4), 16);
        let blue = parseInt(color.slice(4, 6), 16);
        // 有些背景需要设置透明度，用到了rgba颜色值。
        if (tint === 0) {
            return [red, green, blue].join(',')
            //如果是未经压缩的css文件，或scss编译后的css文件，注意rgba中逗号后会有一个空格。
        } else {
            red = Math.round(red * (1 - tint) + 255 * tint);
            green = Math.round(green * (1 - tint) + 255 * tint);
            blue = Math.round(blue * (1 - tint) + 255 * tint);
            red = red.toString(16);
            green = green.toString(16);
            blue = blue.toString(16);
            return `${red}${green}${blue}`;
        }
    }
    // button-active使用的这个色
    const shadeColor = (color, shade) => {
        let red = parseInt(color.slice(0, 2), 16);
        let green = parseInt(color.slice(2, 4), 16);
        let blue = parseInt(color.slice(4, 6), 16);
        red = Math.round((1 - shade) * red);
        green = Math.round((1 - shade) * green);
        blue = Math.round((1 - shade) * blue);
        red = red.toString(16);
        green = green.toString(16);
        blue = blue.toString(16);
        return `${red}${green}${blue}`
    }
    const colors = [theme];
    for (let i = 10; i--;) {
        colors.push(tintColor(theme, i / 10));
    }
    colors.push(shadeColor(theme, 0.1));
    return colors;
},
```

2.获取默认的css，动态创建style元素，内容设置为获取到的css。

3.当用户在颜色选择器中选择完颜色后，以所选的这个颜色为基础色生成一个颜色系列；

4.遍历默认的css，将css中的默认颜色系列换成新生成的颜色系列,并替换掉之前动态创建的style元素的内容。

```javascript
// 更新样式
updateStyle(newTheme) {
    const newColors = this.getColors(newTheme.replace('#', ''));
    let newCustomStyle = this.defaultCustomStyle;
    this.defaultColors.forEach((color, index) => {
        newCustomStyle = newCustomStyle.replace(new RegExp(color, 'ig'), newColors[index]);
    })
    let newElementStyle = this.defaultElementStyle;
    this.defaultColors.forEach((color, index) => {
        newElementStyle = newElementStyle.replace(new RegExp(color, 'ig'), newColors[index]);
    });
    document.head.querySelector("#custom_theme").innerText = newCustomStyle;
    document.head.querySelector("#element_theme").innerText = newElementStyle;
    localStorage.setItem("ms_theme", newTheme);
},
```



##  获取element的默认主题文件

​	element的默认颜色可以直接根据版本号去CDN上获取：

```js
// 获取element的默认样式
getDefaultElementStyle(callback) {
    const version = require('element-ui/package.json').version;
    const url = `https://unpkg.com/element-ui@${version}/lib/theme-chalk/index.css`;
    const xhr = new XMLHttpRequest();
    xhr.onreadystatechange = () => {
        if (xhr.readyState === 4 && xhr.status === 200) {
            this.defaultElementStyle = xhr.responseText.replace(/@font-face{[^}]+}/, ''); //字体文件还是用element的theme-chalk中的
            callback();
        }
    }
    xhr.open("GET", url, true);
    xhr.send();
},
```



##  获取项目中自己编写的主题文件

​      需要将项目中的主题色提取到一个单独的文件中。获取这个css有三种方式：

### 存储在js文件中

​      在一个js文件中将custom-theme样式以字符串存储，然后export。在ThemePicker组件中import这个js文件，就得到了默认的custom-theme样式。

#### 将css文件放在服务器上

 	写一个custom-theme.css文件，不过这个文件要放在后端服务器上,放在前端目录里打包之后请求会出现路径问题。使用时直接从服务器拿到文件，就得到了默认的custom-theme样式。

### 使用scss编写

​	写一个custom-theme.scss文件，要动态改变的颜色值就可以用变量控制，并在这个文件中做一个特殊标记。 在mian.js中import这个scss文件。使用时找到所有的style标签，获取标签的innerText，看哪个标签中有提前做好的标记，那么这个style标签的内容就是所要的默认custom-theme样式。

​	element的默认样式也可以使用这种方式来获取，前提是要在element的index.css文件中手动加上一个特殊标记。

custom-theme.scss

```scss
// 将换肤时需要改变的颜色样式提取到这个文件中
$custom-white: #fff;
$custom-primary:#409eff;

$custom-primary-white__2:mix($custom-white, $custom-primary, 20%);
$custom-primary-white__8:mix($custom-white, $custom-primary, 80%);
$custom-primary-white__9:mix($custom-white, $custom-primary, 90%);

.custom-theme-special-mark {
    content: "277040a3-ee24-9156-6686-56eaad8218a9"
}

.header {
    background-color: $custom-primary;

    .header__logo:hover {
        color: $custom-primary;
    }
}
```

ThemePicker.vue

```javascript
getDefaultCustomStyle() {
    const styles = document.head.querySelectorAll("style");
    Array.from(styles).some(style => {
        const styleText = style.innerText;
        if (styleText.includes("277040a3-ee24-9156-6686-56eaad8218a9")) {
            this.defaultCustomStyle = styleText.replace("277040a3-ee24-9156-6686-56eaad8218a9", "");
            return true;
        }
    })
},
```



